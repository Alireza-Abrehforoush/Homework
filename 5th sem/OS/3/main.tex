\documentclass{article}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[sorting=none]{biblatex}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{float}
\usepackage{hyperref}
\usepackage{xepersian}

\addbibresource{bibliography.bib}
\settextfont[Scale=1.2]{B-NAZANIN.TTF}
\setlatintextfont[Scale=1]{Times New Roman}
\renewcommand{\baselinestretch}{1.5}
\pagestyle{fancy}
\fancyhf{}
\rhead{تکلیف سوم درس سیستم‌های عامل 1 }
\lhead{\thepage}
\rfoot{علیرضا ابره فروش}
\lfoot{9816603}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

%%%%%%%%%%%%%%%%
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
%%%%%%%%%%%%%%%%
\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{سوال اول}

\subsection{آ}
\begin{latin}
\begin{table}[H]
\centering
\caption{}
\label{tab:my-table}
\begin{tabular}{|c|l|l|}
\hline
\textbf{}                          & \multicolumn{1}{c|}{\textbf{Process}}                                                                                                          & \multicolumn{1}{c|}{\textbf{Thread}}                                                                                                                                                                                          \\ \hline
\textbf{1.}                        & \begin{tabular}[c]{@{}l@{}}Process means any program\\ is in execution.\end{tabular}                                                           & Thread means segment of a process.                                                                                                                                                                                            \\ \hline
\textbf{2.}                        & \begin{tabular}[c]{@{}l@{}}Process takes more time\\ to terminate.\end{tabular}                                                                & Thread takes less time to terminate.                                                                                                                                                                                          \\ \hline
\textbf{3.}                        & It takes more time for creation.                                                                                                               & It takes less time for creation.                                                                                                                                                                                              \\ \hline
\textbf{4.}                        & \begin{tabular}[c]{@{}l@{}}It also takes more time for\\ context switching.\end{tabular}                                                       & \begin{tabular}[c]{@{}l@{}}It takes less time for context\\ switching.\end{tabular}                                                                                                                                           \\ \hline
\textbf{5.}                        & \begin{tabular}[c]{@{}l@{}}Process is less efficient in term\\ of communication.\end{tabular}                                                  & \begin{tabular}[c]{@{}l@{}}Thread is more efficient in term\\ of communication.\end{tabular}                                                                                                                                  \\ \hline
\textbf{6.}                        & \begin{tabular}[c]{@{}l@{}}Multi programming holds the\\ concepts of multi process.\end{tabular}                                               & \begin{tabular}[c]{@{}l@{}}We don’t need multi programs\\ in action for multiple threads\\ because a single process consists\\ of multiple threads.\end{tabular}                                                              \\ \hline
\textbf{7.}                        & Process is isolated.                                                                                                                           & Threads share memory.                                                                                                                                                                                                         \\ \hline
\textbf{8.}                        & \begin{tabular}[c]{@{}l@{}}Process is called heavy weight\\ process.\end{tabular}                                                              & \begin{tabular}[c]{@{}l@{}}A Thread is lightweight as each\\ thread in a process shares code,\\ data and resources.\end{tabular}                                                                                              \\ \hline
\textbf{9.}                        & \begin{tabular}[c]{@{}l@{}}Process switching uses interface\\ in operating system.\end{tabular}                                                & \begin{tabular}[c]{@{}l@{}}Thread switching does not require\\ to call a operating system and\\ cause an interrupt to the kernel.\end{tabular}                                                                                \\ \hline
\multicolumn{1}{|l|}{\textbf{10.}} & \begin{tabular}[c]{@{}l@{}}If one process is blocked then it\\ will not effect the execution of\\ other process\end{tabular}                   & \begin{tabular}[c]{@{}l@{}}Second thread in the same task\\ could not run, while one server\\ thread is blocked.\end{tabular}                                                                                                 \\ \hline
\multicolumn{1}{|l|}{\textbf{11.}} & \begin{tabular}[c]{@{}l@{}}Process has its own Process\\ Control Block, Stack and\\ Address Space.\end{tabular}                                & \begin{tabular}[c]{@{}l@{}}Thread has Parents’ PCB, its own\\ Thread Control Block and Stack\\ and common Address space.\end{tabular}                                                                                         \\ \hline
\multicolumn{1}{|l|}{\textbf{12.}} & \begin{tabular}[c]{@{}l@{}}If one process is blocked, then\\ no other process can execute\\ until the first process is unblocked.\end{tabular} & \begin{tabular}[c]{@{}l@{}}While one thread is blocked and\\ waiting, a second thread in the\\ same task can run.\end{tabular}                                                                                                \\ \hline
\multicolumn{1}{|l|}{\textbf{13.}} & \begin{tabular}[c]{@{}l@{}}Changes to the parent process\\ does not affect child processes.\end{tabular}                                       & \begin{tabular}[c]{@{}l@{}}Since all threads of the same process\\ share address space and other \\ resources so any changes to the main\\ thread may affect the behavior of the\\ other threads of the process.\end{tabular} \\ \hline
\end{tabular}
\end{table}
\end{latin}
\subsection{ب}
\begin{itemize}
    \item [$\bullet$] \lr{register set}ِ \lr{thread}ها بین \lr{thread}ها غیر مشترک است. این رجیسترها وضعیت پردازنده را مشخص می‌کنند و \lr{thread}ها عملیات محاسباتی مستقل از یکدیگر دارند بنابراین \lr{virtual register}های نمیتوانند مشترک باشند. مثلا  \lr{Program Counter(PC)} و  \lr{Stack Pointer(SP)} در هر \lr{thread} مجزا و مخصوص به همان \lr{thread} است.

    \item [$\bullet$] \lr{TID}ِ هر \lr{thread} یکتا و مختص همان \lr{thread} است. در واقع داخل یک پروسس، \lr{TID} وجه تمییز بین \lr{thread}های یک پروسس است. پس نمی‌تواند مشترک باشد.

   \item [$\bullet$] \lr{stack}ِ هر \lr{thread}، متغیرهای محلی و آدرس بازگشتی را به صورت مجزا ذخیره می‌کنند.
\end{itemize}

\subsection{ج}
برای مدلسازی بسیاری از مسائل موجود در دنیای واقعی که به نحوی چند کار باهم همزمانی دارند به برنامه‌های \lr{concurrent} نیاز داریم و نمی‌توانیم تنها به متدهای برنامه‌نویسیِ خطی و ترتیبی اتکا کنیم. برنامه‌نویسی چندنخی در این زمینه به ما کمک می‌کند، به طوریکه به هر یک از کارهای همزمان یک \lr{thread} نظیر می‌کنیم و این تعاملِ \lr{thread}ها باهم روند یک کار را به طور دقیق مدل می‌کند.
\subsection{د}
در پردازنده‌های تک هسته‌ای هنگامی که یک \lr{thread} منتظر \lr{I/O} سنکرون است، \lr{scheduler}،  \lr{thread}های دیگر را(برای مثال \lr{read()}) \lr{schedule} می‌کند و هدر رفت زمان کمتر رخ می‌دهد. از دیگر مزایای برنامه‌نویسی چندنخی در پردازنده‌های تک هسته‌ای عدم جا‌به‌جایی ترتیب اجرای دستورات در بسیاری از پیاده‌سازی‌ها است. مشکل \lr{data race} نیز به دلیل عدم وجود پیچیدگی در ترتیب اجرای دستورات، رفع می‌شود.
\subsection{ه}
ججججججججججججججججج

\subsection{و}
\lr{Ticketlock}ها بر خلاف \lr{Spinlock}ها مشکل گرسنگی مفرط ندارند. \lr{Fetch and Add} نیز دچار گرسنگی مفرط نمی‌شود.
\subsection{ز}
4 منبع و 3 رشته داریم. درنتیجه حداقل یکی از رشته‌ها حداقل 2 تا از منابع را اشغال می‌کند و \lr{circular wait} رخ نمی‌دهد. پس \lr{Deadlock} نمی‌تواند رخ دهد.
\newpage

\section{سوال دوم}
\subsection{طول بافر محدود}
\lr{\lstinputlisting[language=C, showstringspaces=false, basicstyle=\ttfamily]{sources/2.1.c}}
\subsection{طول بافر بی‌نهایت}
\lr{\lstinputlisting[language=C, showstringspaces=false, basicstyle=\ttfamily]{sources/2.2.c}}

\section{سوال سوم}
برای اینکه ثابت کنیم روش ارائه شده مسئله \lr{Critical Section} را حل می‌کند باید ثابت کنیم که:
\begin{itemize}
    \item [$\bullet$] در هر زمان تنها یک پروسس می‌تواند داخل \lr{critical section} باشد. اگر پروسس‌های دیگری بخواهند به \lr{critical section} دسترسی پیدا کنند باید صبر کنند تا آزاد شود.(\lr{Mutual Exclusion})

    \item [$\bullet$] اگر یک پروسس از \lr{critical section} استفاده نمی‌کند نباید پروسس دیگری را از دسترسی به آن بازدارد. به عبارت دیگر هر پروسسی می‌تواند وارد یک \lr{critical section} شود اگر آزاد باشد.(\lr{Progress})

    \item [$\bullet$] هر پروسس الزاما باید یک زمان انتظار محدود داشته باشد و تا ابد برای دسترسی به \lr{critical section} منتظر نماند.(\lr{Bounded Waiting})
\end{itemize}
حال هر یک از موارد بالا را ثابت می‌کنیم.
\newpage

\begin{itemize}
    \item [$\bullet$] \lr{Mutual Exclusion}: توجه شود که یک پروسس تنها زمانی که شرط ذیل ارضا شود، وارد \lr{critical section} می‌شود:
\newline
مقدار \lr{flag}ِ هیچ پروسس دیگری برابر \lr{in\_cs} نشود. از آنجایی که پروسس قبل از اینکه وضعیت پروسس‌های دیگر را چک کند مقدار \lr{flag}ِ خود را برابر با \lr{in\_cs} قرار می‌دهد، تضمین می‌شود که هیچ دو پروسسی به طور همزمان وارد \lr{critical section} نخواهند شد.

    \item [$\bullet$] \lr{Progress}: شرایطی را در نظر بگیرید که چند پروسس به طور همزمان بخواهند مقادیر \lr{flag}شان را برابر با \lr{in\_cs} قرار دهند و سپس چک کنند که آیا پروسس دیگری \lr{flag}ش را برابر با \lr{in\_cs} قرار داده است یا خیر. وقتی این اتفاق رخ می‌دهد، همه پروسس‌ها متوجه می‌شوند که پروسس‌های رقیب وجود دارند و وارد پیمایش بعدیِ \lr{while(1)}ِ بیرونی می‌شوند و مقادیر \lr{flag}شان به \lr{want\_in} برمی‌گردانند. حال تنها پروسسی که مقدارِ \lr{turn}ش را برابر با \lr{in\_cs} قرار می‌دهد، پروسسی است که نزدیک ترین \lr{index} به \lr{turn} را دارد. هرچند ممکن است که پروسس‌هایی جدید با \lr{index}های حتی نزدیک‌تر به \lr{turn} وجود داشته باشند که تصمیم بگیرند در این نقطه وارد \lr{critical section} شوند ونتیجتا قادر باشند به شکل همزمان مقدار \lr{flag}ِ خود را برابر با \lr{in\_cs} قرار بدهند. این پروسس‌ها درنهایت متوجه می‌شوند که پروسس‌های رقیبی وجود دارند که ممکن است پروسسی که درحال وارد شدن به \lr{critical section} است را بازنشانی کند. هرچند در هر پیمایش، مقادیر \lr{index}ِ پروسس‌هایی که مقادیر \lr{flag}ِ خود را برابر با \lr{in\_cs} قرار داده‌اند، به \lr{turn} نزدیک‌تر شده و در نهایت به شرط ذیل می‌رسند:
\newline
تنها یک پروسس \lr{flag}ش را برابر با \lr{in\_cs} قرار می‌دهد و هیچ پروسس دیگری که \lr{index}ش بین این پروسس و \lr{turn} قرار دارد، \lr{flag}ش را برابر با \lr{in\_cs} قرار نمی‌دهد. پس این تنها پروسسی است که وارد \lr{critical section} می‌شود.

    \item [$\bullet$] \lr{Bounded Waiting}: این شرط به این دلیل ارضا می‌شود که هرگاه پروسسِ \lr{k} بخواهد وارد \lr{critical section} شود \lr{flag}ش دیگر برابر با \lr{idle} نمی‌باشد. در نتیجه، هر پروسسی که \lr{index}ش بین \lr{k} و \lr{turn} قرار نداشته باشد نمی‌تواند وارد \lr{critical section} بشود. در این حال، همه پروسس‌هایی که \lr{index}شان بین \lr{k} و \lr{turn} قرار دارد و مایلند که وارد \lr{critical section} شوند(باتوجه به اینکه سیستم همواره پیشروی می‌کند)، فورا وارد \lr{critical section} می‌شوند و مقدار \lr{turn} به طور یکنواخت به \lr{k} نزدیک می‌شود. درنهایت چه \lr{turn} با \lr{k} برابر شود و چه هیچ پروسسی وجود نداشته باشد که \lr{index}ش بین \lr{k} و \lr{turn} قرار داشته باشد، پروسسِ \lr{k} وارد \lr{critical section} می‌شود.
\end{itemize}

\section{سوال چهارم}

\section{سوال پنجم}


\section*{منابع}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{99} % assumes less than 100 references
%چنانچه مرجع فارسی نیز داشته باشید باید دستور فوق را فعال کنید و مراجع فارسی خود را بعد از این دستور وارد کنید


\begin{LTRitems}

\resetlatinfont

\bibitem{b1}https://gateoverflow.in/150841/Tlb-and-page-fault

\end{LTRitems}

\end{thebibliography}


\end{document}
