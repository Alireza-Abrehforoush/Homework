\documentclass{article}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[sorting=none]{biblatex}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{float}
\usepackage{hyperref}
\usepackage{xepersian}

\addbibresource{bibliography.bib}
\settextfont[Scale=1.2]{B-NAZANIN.TTF}
\setlatintextfont[Scale=1]{Times New Roman}
\renewcommand{\baselinestretch}{1.5}
\pagestyle{fancy}
\fancyhf{}
\rhead{تکلیف دوم درس سیستم‌های عامل 1 }
\lhead{\thepage}
\rfoot{علیرضا ابره فروش}
\lfoot{9816603}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

%%%%%%%%%%%%%%%%
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
%%%%%%%%%%%%%%%%
\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{سوال اول}

\subsection{آ}
\begin{latin}
\begin{table}[H]
\caption{}
\label{tab:my-table}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|l|l|}
\hline
\textbf{}   & \multicolumn{1}{c|}{\textbf{Internal Fragmentation}}                                                                                                                                                  & \multicolumn{1}{c|}{\textbf{External Fragmentation}}                                                                                                                                    \\ \hline
\textbf{1.} & \begin{tabular}[c]{@{}l@{}}In internal fragmentation fixed-sized memory,\\ blocks square measure appointed to process.\end{tabular}                                                                   & \begin{tabular}[c]{@{}l@{}}In external fragmentation, variable-sized\\ memory blocks square measure\\ appointed to method.\end{tabular}                                                 \\ \hline
\textbf{2.} & \begin{tabular}[c]{@{}l@{}}Internal fragmentation happens when the\\ method or process is larger than the memory.\end{tabular}                                                                        & \begin{tabular}[c]{@{}l@{}}External fragmentation happens when the\\ method or process is removed.\end{tabular}                                                                         \\ \hline
\textbf{3.} & \begin{tabular}[c]{@{}l@{}}The solution of internal fragmentation\\ is best-fit block.\end{tabular}                                                                                                   & \begin{tabular}[c]{@{}l@{}}Solution of external fragmentation is\\ compaction, paging and segmentation.\end{tabular}                                                                    \\ \hline
\textbf{4.} & \begin{tabular}[c]{@{}l@{}}Internal fragmentation occurs when\\ memory is divided into fixed sized partitions.\end{tabular}                                                                           & \begin{tabular}[c]{@{}l@{}}External fragmentation occurs when memory\\ is divided into variable size partitions\\ based on the size of processes.\end{tabular}                          \\ \hline
\textbf{5.} & \begin{tabular}[c]{@{}l@{}}The difference between memory allocated\\ and required space or memory is called\\ Internal fragmentation.\end{tabular}                                                    & \begin{tabular}[c]{@{}l@{}}The unused spaces formed between\\ non-contiguous memory fragments are too\\ small to serve a new process, is called\\ External fragmentation .\end{tabular} \\ \hline
\textbf{6.} & \begin{tabular}[c]{@{}l@{}}Internal fragmentation occurs\\ with paging and fixed partitioning.\end{tabular}                                                                                           & \begin{tabular}[c]{@{}l@{}}External fragmentation occurs with\\ segmentation and dynamic partitioning.\end{tabular}                                                                     \\ \hline
\textbf{7.} & \begin{tabular}[c]{@{}l@{}}It occurs on allocation of a process to a\\ partition greater than the process’s requirement.\\ The left over space causes degradation system \\ performance.\end{tabular} & \begin{tabular}[c]{@{}l@{}}It occurs on allocation of a process to a\\ partition greater which is exactly\\ the same memory space as it is required.\end{tabular}                       \\ \hline
\end{tabular}%
}
\end{table}
\end{latin}
\subsection{ب}
سطوح مختلف حافظه مثل کش، هارد درایو، رم و غیره هر کدام سرعت و حجم متفاوتی را ارائه می‌دهند. علی‌رغم اینکه کش سریع‌ترین حافظه است اما نمی‌توانیم که در همه جای سیستم، از کش استفاده کنیم، چون هزینه بالایی دارد. همچنین نمی‌توانیم همه جا از هارد استفاده کنیم چون سرعت کمی دارد و فضای زیادی اشغال می‌کند، درحالی که ارزان است. از سطوح مختلف برای برقراری تعادل میان سرعت و حجم استفاده می‌شود. در \lr{cpu} که سرعت بالایی دارد ناچاریم از کش‌ها استفاده کنیم و نمی‌توانیم از حافظه‌ی رم کمک بگیریم. نوع حافظه‌ها که بسته به برق اطلاعاتشان پاک می‌شود و احتیاج است که گاهی اطلاعات ماندگار باشد و گاهی نیازی نیست، یکی از دلایل دیگر آن است. سطوح مختلف حافظه با این هدف شکل گرفته است که داده‌هایی که غالبا توسط برنامه‌ها مورد استفاده قرار می‌گیرند در سطوح بالایی از سلسله مراتب حافظه نگهداری شوند و اغلب درخواست‌ها به حافظه توسط همین سطوح بالاتر مورد پردازش قرار گیرند. در نتیجه حداکثر سرعت را با حداقل هزینه به دست آورده‌ایم.

\subsection{ج}
از آن جایی که اندازه‌ی فضای \lr{Stack} به صورت پایین‌رونده و فضای \lr{Heap} به صورت بالارونده حین اجرا ممکن است افزایش یابد، درصورت متوالی بودن \lr{conflict} رخ می‌دهد.
\subsection{د}
در پروسس‌هایی که نمونه‌های مستقل یک برنامه هستند(درواقع بخش \lr{code segment} آن‌ها یکسان است)، \lr{code segment} آن‌ها در مکان‌های یکسان ذخیره شده است و رجیسترهای \lr{base} و \lr{bounds}ِ مربوط به \lr{code segment} مقادیر یکسان دارند، و \lr{stack segment} و \lr{heap segment} دو پروسس مستقل از هم هستند. چون هر دوی این پروسس‌ها به \lr{code segment} دسترسی دارند باید اجازه نوشتن در این قسمت از آن‌ها سلب شود تا در عملکرد دیگری اختلال ایجاد نکند و این پشتیبانیِ سخت‌افزاری را می‌طلبد. در نتیجه اطلاعات مربوط به \lr{protection} که اجازه‌های خواندن، نوشتن و اجرا هستند را به هر \lr{segment} اضافه می‌کنیم.
\subsection{ه}
بزرگی اندازه‌ی \lr{Paging} موجب کوچک شدن \lr{page table}ها می‌شود. درنتیجه احتمال وقوع \lr{page fault} را کاهش می‌دهد. همچنین میزان سربار کمتر است. اما \lr{internal fragmentation} در این حالت بیشتر است. همچنین \lr{locality of reference} نیز کاهش می‌یابد.
\newline
کوچکی اندازه‌ی \lr{Paging}،  \lr{internal fragmentation} را کاهش می‌دهد و همچنین \lr{locality of reference} نیز افزایش می‌یابد. اما در این حالت \lr{page table}ها بزرگتر هستند و درنتیجه احتمال وقوع \lr{page fault} را بیشتر است. از طرفی دیگر میزان سربار بیشتر است.
\subsection{و}
سربار ناشی از انجام این عملیات توسط سخت‌افزار زیاد است، چون اولا دسترسی به بسیاری از جزئیات(برای مثال \lr{swap space}) به شکل سخت‌افزاری به شدت پیچیده می‌شود. همچنین دیسک کند است و عملیاتِ انجام گرفته توسط آن نسبت به حالت نرم‌افزاری بسیار زمان‌بر است. پس رسیدگی به آن به صورت نرم‌افزاری به‌صرفه‌تر است.
\subsection{ز}
رجیسترِ \lr{CR3} برای هر پروسس \lr{base}ِ \lr{page table}ِ مربوط به آن پروسس را مشخص می‌کند.
\subsection{ح}
با توجه به منبع شماره‌ی 1 در قسمت منابع به ترتیب داریم:
\begin{itemize}
    \item [$\bullet$] درصورتی که آدرس ترجمه شده در \lr{TLB} وجود نداشته باشد \lr{TLB Miss} رخ می‌دهد. پس به \lr{PTE} مربوطه مراجعه می‌شود و درصورت \lr{set} بودن بیت \lr{valid}(\lr{present})، \lr{page fault} رخ نمی‌دهد.
    \item [$\bullet$] درصورتی که به \lr{PTE}ای که بیت \lr{valid}ِ آن صفر است اشاره کند، دسترسی غیرمجاز به حافظه تلقی می‌شود. اما اگر \lr{PTE} وجود نداشته باشد نشانگر این است که صفحه در \lr{physical memory address space} قرار ندارد.
    \item [$\bullet$] درصورتی که \lr{TLB Hit} رخ دهد و بیتِ \lr{valid}ِ \lr{PTE}ِ نظیر آن یک باشد \lr{page fault} رخ نخواهد داد.
    \item [$\bullet$] فرض که \lr{TLB Hit} رخ داده است، اما حین دسترسی به یک \lr{trap} برمی‌خوریم که احتمالا به دلیل این است که تلاش می‌کنیم به قسمتی که \lr{Read-only} است دسترسی پیدا کنیم.
\end{itemize}

\section{سوال دوم}
\begin{latin}
\begin{table}[H]
\caption{LRU}
\label{tab:my-table}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Access} & \textbf{Hit} & \textbf{State(after)} \\ \hline
\textbf{2}      & no           & 2                     \\ \hline
\textbf{3}      & no           & 2, 3                  \\ \hline
\textbf{1}      & no           & 2, 3, 1               \\ \hline
\textbf{5}      & no           & 2, 3, 1, 5            \\ \hline
\textbf{6}      & no           & 3, 1, 5, 6            \\ \hline
\textbf{2}      & no           & 1, 5, 6, 2            \\ \hline
\textbf{1}      & yes          & 5, 6, 2, 1            \\ \hline
\textbf{5}      & yes          & 6, 2, 1, 5            \\ \hline
\textbf{3}      & no           & 2, 1, 5, 3            \\ \hline
\textbf{2}      & yes          & 1, 5, 3, 2            \\ \hline
\textbf{6}      & no           & 5, 3, 2, 6            \\ \hline
\textbf{5}      & yes          & 3, 2, 6, 5            \\ \hline
\textbf{4}      & no           & 2, 6, 5, 4            \\ \hline
\textbf{3}      & no           & 6, 5, 4, 3            \\ \hline
\textbf{2}      & no           & 5, 4, 3, 2            \\ \hline
\end{tabular}
\end{table}
\end{latin}
\begin{latin}
\begin{table}[H]
\caption{LFU}
\label{tab:my-table}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Access} & \textbf{Hit} & \textbf{State(after)} \\ \hline
\textbf{2}      & no           & 2                     \\ \hline
\textbf{3}      & no           & 2, 3                  \\ \hline
\textbf{1}      & no           & 2, 3, 1               \\ \hline
\textbf{5}      & no           & 2, 3, 1, 5            \\ \hline
\textbf{6}      & no           & 6, 3, 1, 5            \\ \hline
\textbf{2}      & no           & 2, 6, 1, 5            \\ \hline
\textbf{1}      & yes          & 2, 6, 1, 5            \\ \hline
\textbf{5}      & yes          & 2, 6, 1, 5            \\ \hline
\textbf{3}      & no           & 3, 2, 1, 5            \\ \hline
\textbf{2}      & yes          & 3, 2, 1, 5            \\ \hline
\textbf{6}      & no           & 6, 2, 1, 5            \\ \hline
\textbf{5}      & yes          & 6, 2, 1, 5            \\ \hline
\textbf{4}      & no           & 4, 2, 1, 5            \\ \hline
\textbf{3}      & no           & 3, 2, 1, 5            \\ \hline
\textbf{2}      & yes          & 3, 2, 1, 5            \\ \hline
\end{tabular}
\end{table}
\end{latin}
\begin{latin}
\begin{table}[H]
\caption{Optimal}
\label{tab:my-table}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Access} & \textbf{Hit} & \textbf{State(after)} \\ \hline
\textbf{2}      & no           & 2                     \\ \hline
\textbf{3}      & no           & 2, 3                  \\ \hline
\textbf{1}      & no           & 1, 2, 3               \\ \hline
\textbf{5}      & no           & 3, 5, 1, 2            \\ \hline
\textbf{6}      & no           & 6, 5, 1, 2            \\ \hline
\textbf{2}      & yes          & 6, 2, 5, 1            \\ \hline
\textbf{1}      & yes          & 1, 6, 2, 5            \\ \hline
\textbf{5}      & yes          & 1, 5, 6, 2            \\ \hline
\textbf{3}      & no           & 3, 5, 6, 2            \\ \hline
\textbf{2}      & yes          & 3, 5, 6, 2            \\ \hline
\textbf{6}      & yes          & 6, 2, 3, 5            \\ \hline
\textbf{5}      & yes          & 6, 5, 2, 3            \\ \hline
\textbf{4}      & no           & 5, 4, 2, 3            \\ \hline
\textbf{3}      & yes          & 5, 4, 2, 3            \\ \hline
\textbf{2}      & yes          & 5, 4, 2, 3            \\ \hline
\end{tabular}
\end{table}
\end{latin}

\section{سوال سوم}
ابتدا بررسی می‌کنیم که \lr{TLB Miss} رخ داده است یا \lr{TLB Hit}. این کار در 1 نانو ثانیه انجام می‌شود. سپس دو حالت زیر را در نظر می‌گیریم:
\begin{itemize}
    \item [$\bullet$] \lr{TLB Miss} رخ دهد. در این حالت داریم:
$
P_{TLBMiss}(2*T_{DRAM}+P_{PageFault}*T_{Disk})=4ns
$
    \item [$\bullet$] \lr{TLB Miss} رخ ندهد. در این حالت داریم:
$
(1-P_{TLBMiss})*(T_{Cache}+P_{CacheMiss}*P_{PageFault}*T_{Disk})=2.97ns
$
در نهایت ميانگين زمان دسترسي به صفحات حافظه برابر است با:
$
1ns+4ns+2.97ns=7.97ns
$
\end{itemize}
\section{سوال چهارم}
\subsection{الف}
گام اول: تجزیه‌ی آدرس مجازی به \lr{Seg}، \lr{VPN}، و \lr{Offset}:
\newline
2 بیت پرارزش مربوط به سگمنت است، چون صفحه‌ها 32 بایتی هستند پس 5 بیت برای نشان دادن آن‌ها نیاز داریم که از راست برای آفست جدا می‌کنیم و 5 بیت باقی‌مانده برای \lr{VPN} است.
\newline
\lr{0x45d\ =\ 01\ 00010\ 11101}
\newline
\lr{SN\ =\ 01}
\newline
\lr{VPN\ =\ 00010 =\ 2}
\newline
\lr{Offset\ =\ 11101 =\ 29}
\newline
\newline
\lr{Address of PTE\ =\ Base[SN]\ +\ VPN*sizeof(PTE) = 64 + 2*1 = 66}
\newline
بایت 66 در صفحه‌ی با \lr{PFN = 2} قرار دارد و بایت سوم آن است.
\newline
\lr{Page with PFN = 2: c3}
\newline
\lr{c3 =\ 1\ 1000011 =\ 67}
\newline
\lr{valid bit =\ 1}
\newline
\lr{PFN =\ 67}
\newline
آفست 29 در صفحه‌ی 67 که آدرس 40 است. پس براي ترجمه آدرس مجازي به آدرس فيزيكي، به صفحات 2 و 67 رجوع مي‌شود.
\newline
بله چون بیتِ \lr{valid} یک است و بایت مورد نظر \lr{c3} است که در صفحه‌ی 2 قرار دارد.
\subsection{ب}
گام اول: تجزیه‌ی آدرس مجازی به \lr{Seg}، \lr{VPN}، و \lr{Offset}:
\newline
2 بیت پرارزش مربوط به سگمنت است، چون صفحه‌ها 32 بایتی هستند پس 5 بیت برای نشان دادن آن‌ها نیاز داریم که از راست برای آفست جدا می‌کنیم و 5 بیت باقی‌مانده برای \lr{VPN} است.
\newline
\lr{0xc85\ =\ 11\ 00100\ 00101}
\newline
\lr{SN\ =\ 11}
\newline
\lr{VPN\ =\ 00100 =\ 4}
\newline
\lr{Offset\ =\ 00101 =\ 5}
\newline
\newline
\lr{Address of PTE\ =\ Base[SN]\ +\ VPN*sizeof(PTE) = 640 + 4*1 = 644}
\newline
بایت 644 در صفحه‌ی با \lr{PFN = 20} قرار دارد و بایت پنجم آن است.
\newline
\lr{Page with PFN = 20: 20}
\newline
\lr{20 =\ 0\ 0100000}
\newline
\lr{valid bit =\ 0}
\newline
خیر چون بیتِ \lr{valid} صفر است، اين آدرس مجازي به اين پروسس تخصيص داده نشده است و تنها به صفحه‌ی 20 رجوع می‌شود.

\section*{منابع}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{99} % assumes less than 100 references
%چنانچه مرجع فارسی نیز داشته باشید باید دستور فوق را فعال کنید و مراجع فارسی خود را بعد از این دستور وارد کنید


\begin{LTRitems}

\resetlatinfont

\bibitem{b1}https://gateoverflow.in/150841/Tlb-and-page-fault

\end{LTRitems}

\end{thebibliography}


\end{document}
