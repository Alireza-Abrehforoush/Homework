\documentclass{article}

\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[sorting=none]{biblatex}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{float}
\usepackage{hyperref}
\usepackage{xepersian}

\addbibresource{bibliography.bib}
\settextfont[Scale=1.2]{B-NAZANIN.TTF}
\setlatintextfont[Scale=1]{Times New Roman}
\renewcommand{\baselinestretch}{1.5}
\pagestyle{fancy}
\fancyhf{}
\rhead{تکلیف اول درس سیستم‌های عامل 1 }
\lhead{\thepage}
\rfoot{علیرضا ابره فروش}
\lfoot{9816603}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}

%%%%%%%%%%%%%%%%
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
%%%%%%%%%%%%%%%%
\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{عنوان سوال اول}
اگر سوال بخش\,بندی\,شده نباشد، پاسخ آن در این قسمت نوشته می\,شود.
\subsection{عنوان بخش اول سوال اول}
پاسخ بخش اول سوال در این قسمت نوشته می\,شود.
\subsection{عنوان بخش دوم سوال اول}
پاسخ بخش دوم سوال در این قسمت نوشته می\,شود.
\subsection{عنوان بخش سوم سوال اول}
پاسخ بخش دوم سوال در این قسمت نوشته می\,شود.
\subsection{عنوان بخش چهارم سوال اول}
محتوای برخی از رجیستر‌ها مانند \lr{Program Counter} یا \lr{Stack Pointer} توسط \lr{kernel handler} قابل ذخیره‌سازی نیستند. چون خود آن‌ها هم نرم‌افزار هستند و تا \lr{CPU} بخواهد آن‌ها را وارد مرحله اجرا کند، محتوای \lr{Program Counter} و \lr{Stack Pointer} عوض می‌شود. پس سخت افزار قبل از فراخوانی  \lr{kernel handler}، به طور خودکار محتوای رجیستر‌های برخی از پروسس‌های متوقف شد را با \lr{push} کردن آن‌ها در \lr{interrup stack} حفظ می‌کند.
\subsection{عنوان بخش پنجم سوال اول}
پاسخ بخش دوم سوال در این قسمت نوشته می\,شود.
\subsection{عنوان بخش ششم سوال اول}
پاسخ بخش دوم سوال در این قسمت نوشته می\,شود.
\subsection{عنوان بخش هفتم سوال اول}
پاسخ بخش دوم سوال در این قسمت نوشته می\,شود.

\section{عنوان سوال دوم}
\indent
سیستم کال \lr{fork()} یک پروسس جدید به نام پروسس \lr{child} می‌سازد. پس از ایجاد پروسس \lr{child}، هر دو پروسس(\lr{child} و \lr{parent}ش)دستوراتی که پس از \lr{fork()} متناظرشان آمده اند را یک به یک اجرا می‌کنند. به این ترتیب پس از اولین \lr{fork()}، در مجموع 2 پروسس، پس از دومین \lr{fork()}، در مجموع 4 پروسس، پس از سومین \lr{fork()}، در مجموع هشت پروسس و $\ldots$، خواهیم داشت. درنتیجه پس از اجرای حلقه، تعداد \lr{child}های ایجاد شده برابر است با:

\begin{center}
$
2+4+\ldots+2^{\log_2 n}=2^{(\log_2 n)+1}=2n
$
\end{center}
در مجموع با احتساب پروسس \lr{parent} اصلی، \lr{n}2 پروسس خواهیم داشت.

\section{عنوان سوال سوم}
در این قسمت با نحوه درج روابط و فرمول\,ها آشنا می\,شوید:
\begin{center}
$E = m{c}^{2}$
\end{center}

\section{عنوان سوال چهارم}
در این قسمت با نحوه درج اشکال آشنا می\,شوید:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{IUT Logo.png}
    \caption{شکل شماره 1}
    \label{fig:fig1}
\end{figure}

\section{عنوان سوال پنجم}
\subsection{}
\lr{\lstinputlisting[language=C, showstringspaces=false, basicstyle=\ttfamily]{sources/collatz_conjecture.c}}

\subsection{}
زیرا در \lr{UNIX/POSIX}، \lr{exit code}ِ یک برنامه از نوع \lr{unsigned 8-bit} تعریف شده است. به طور دقیق‌تر \lr{system call}های خانواده \lr{wait} در \lr{UNIX} نتیجه یک پروسس را به یک \lr{32-bit integer} کدگذاری می‌کنند. از این 32 بیت برای اطلاعاتی همچون وقوع یا عدم وقوع \lr{dump core} در پروسس، \lr{exit} به دلیل یک سیگنال(و چه سیگنالی)، و $\ldots$ تقسیم می‌شود. از این رو تنها 8 بیت از 32 بیت برای \lr{exit code} باقی می‌ماند.
\subsection{}


\section{عنوان سوال ششم}
\subsection{}
\textbf{\lr{orphan process}:}
پروسسی که \lr{parent}ش وجود ندارد(یا پایان یافته یا بدون اینکه برای متوقف شدن \lr{child}ش صبر کرده باشد، متوقف شده باشد)، \lr{orphan process} نامیده می‌شود.
\newline
\textbf{\lr{zombie process}:}
پروسسی که اجرای آن پایان یافته است اما هنوز در جدول پروسس‌ها مقداری دارد که به پروسس \lr{parent} نسبت داده می‌شود، \lr{zombie process} نامیده می‌شود. یک پروسس \lr{child} همواره پیش از پاک شدن از جدول پروسس‌ها به یک \lr{zombie process} تبدیل می‌شود. پروسس \lr{parent}، \lr{exit status} پروسس \lr{child} را می‌خواند و پروسس \lr{child} از جدول پروسس‌ها حذف می‌شود.
\subsection
\indent
برنامه‌ی 1 یک \lr{orphan process} ایجاد می‌کند. چون پروسس \lr{child} حدودا 101 ثانیه پس از پایان یافتن پروسس \lr{parent} به پایان می‌رسد. همینطور که در تصویر اول مشهود است، مقدار \lr{ppidِ}ِ پروسس \lr{child} پس از ثانیه اول برابر 2174(\lr{pidِ}ِ پروسس \lr{parent}) است اما پس از ثانیه سوم(پایان یافتن پروسس \lr{parent}) این مقدار برابر 1286(\lr{pid}ِ پروسس \lr{systemd} که نقش \lr{subreaper} را برای پروسس \lr{orphan} برعهده دارد و در قسمت بالای جدول پروسس‌ها قرار دارد) می‌باشد.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/5.2.1.1.png}
    \caption{اجرای برنامه‌ی 1}
    \label{fig:fig1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/5.2.1.2.png}
    \caption{جدول پروسس‌ها(قسمت پایین)}
    \label{fig:fig1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/5.2.1.3.png}
    \caption{جدول پروسس‌ها(قسمت بالا)}
    \label{fig:fig1}
\end{figure}
%%%%%%%%%%%%%

برنامه‌ی 2 یک \lr{zombie process} ایجاد می‌کند. چون پروسس \lr{parent} حدودا 99 ثانیه پس از پایان یافتن پروسس \lr{child} به پایان می‌رسد. اگر در این بازه زمانی جدول پروسس‌ها را بررسی کنیم می‌بینیم که پروسسی با \lr{STAT}ِ \lr{Z} وجود دارد که \lr{pid}ش برابر \lr{pid}ِ پروسس \lr{child} است و این نشان‌دهنده این است که برنامه‌ی 2 یک \lr{zombie process} تولید کرده است. به تصاویر زیر توجه کنید:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/5.2.2.1.png}
    \caption{اجرای برنامه‌ی 2}
    \label{fig:fig1}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/5.2.2.2.png}
    \caption{جدول پروسس‌ها}
    \label{fig:fig1}
\end{figure}
تتتتتتتتتتتتتتتتتتتتتتتت

\section{عنوان سوال جدول}
در این قسمت با نحوه درج جداول آشنا می\,شوید:
\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|c|}
    \hline
    خانه شماره 1 & خانه شماره 2 & خانه شماره 3\\
    \hline
    خانه شماره 4 & خانه شماره 5 & خانه شماره 6\\
    \hline
    خانه شماره 7 & خانه شماره 8 & خانه شماره 9\\
    \hline
    \end{tabular}
    \caption{جدول شماره 1}
    \label{tab:tab1}
\end{table}

\section{عنوان سوال ششم}
در این قسمت با نحوه درج انواع لیست\,ها آشنا می\,شوید:
\subsection{عنوان بخش اول سوال ششم}
\begin{itemize}
    \item [$\bullet$] مورد اول
    \item [$\bullet$] مورد دوم
\end{itemize}
\subsection{عنوان بخش دوم سوال ششم}
\begin{enumerate}
    \item مورد شماره 1
    \item مورد شماره 2
\end{enumerate}

\section{عنوان سوال هفتم}
در این قسمت با نحوه درج برنامه\,ها آشنا می\,شوید:
\lr{\lstinputlisting[language=C, showstringspaces=false, basicstyle=\ttfamily]{Source.c}}

\section{عنوان سوال هشتم}
در این قسمت با نحوه ارجاع به سایر منابع آشنا می\,شوید:\\
\indent
به صفحه درس سیستم عامل دکتر محمّدرضا حیدرپور ارجاع داده می\,شود \cite{b1}.

\section{ضمیمه}
برای آشنایی بیشتر با \lr{\LaTeX}، با جست\,و\,جو در اینترنت منابع مفیدی خواهید یافت.

%\printbibliography[title=منابع]

\section*{منابع}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{99} % assumes less than 100 references
%چنانچه مرجع فارسی نیز داشته باشید باید دستور فوق را فعال کنید و مراجع فارسی خود را بعد از این دستور وارد کنید


\begin{LTRitems}

\resetlatinfont

\bibitem{b1} http://mrheidar.ir/courses/operating\_system.html
\end{LTRitems}

\end{thebibliography}


\end{document}
