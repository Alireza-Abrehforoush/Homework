\documentclass{article}

\usepackage{graphicx}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage{amsfonts}
\usepackage{textcomp}
\usepackage{float}
\usepackage[sorting=none]{biblatex}
\usepackage[margin=1in]{geometry}
\usepackage[font={small,it}]{caption}
\usepackage{placeins}
\usepackage{xepersian}

%\DeclareMathOperator*{\btie}{\bowtie}
\addbibresource{bibliography.bib}
\settextfont[Scale=1.2]{B-NAZANIN.TTF}
\setlatintextfont[Scale=1]{Times New Roman}
\renewcommand{\baselinestretch}{1.5}
\pagestyle{fancy}
\fancyhf{}
\rhead{تکلیف دوم درس هوش مصنوعی (بخش تئوری)}
\lhead{\thepage}
\rfoot{علیرضا ابره فروش}
\lfoot{9816603}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
%%%%%%%%%%
\lstset
{
    language=[latex]tex,
    basicstyle=\ttfamily,
    commentstyle=\color{black},
    columns=fullflexible,
    keepspaces=true,
    upquote=true,
    showstringspaces=false,
    morestring=[s]\\\%,
    stringstyle=\color{black},
}
%%%%%%%%%%
%beginMatlab
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}
%endMatlab
\begin{document}
%beginMatlab
\lstset{language=Matlab,%
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    numbers=left,%
    numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=9pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
}
%endMatlab
\input{titlepage}

%\tableofcontents
\newpage


\section{نوید زندانی}
\subsection{}
\subsubsection{\lr{binary}}

\subsubsection{\lr{unary}}

\subsection{}
\subsection{}
\subsection{}
\subsection{}
\subsection{}



\section{مسئله سه رنگ}
هر \lr{Candidate solution} در این مسئله را می‌توان نظیر یک رشته به طول $n$ از اعداد موجود در مجموعه‌ی $G_{l}$ در نظر گرفت (نمایش اعداد صحیح) به طوری که $i$ بودن کاراکترِ $m$ام به معنی قرار گرفتن جسمِ $m$ام در ستونِ $i$ام است. همچنین مجموعه‌ی همسایگی نظیر یک \lr{Candidate solution} را می‌توان به شکل مجموعه‌ی همه‌ی رشته‌هایی که با رشته مذکور دقیقا در یک کاراکتر اختلاف دارند، تعریف کرد.



\section{\lr{consistency}}
هر \lr{Candidate solution} در این مسئله را می‌توان به یک جایگشت از اعداد 1 تا $n$ نظیر کرد به طوری که $i$ بودنِ جایگاه $m$ام به معنی نگاشتِ مرکز رفاهیِ $i$ به مکانِ $m$ است. مجموعه‌ی شامل همه‌ی جایگشت‌های اعداد 1 تا $n$ را با $P_{n}$ نشان می‌دهیم.
به ازای هر جایگشت در $P_{n}$، تابعِ $\phi$ را تعریف می‌کنیم نگاشت از مرکز رفاهی به مکان نظیرِ آن مرکز رفاهی در آن جایگشت. همچنین مجموعه‌ی 
$
S_{n}
$
را تعریف می‌کنیم مجموعه‌ی همه‌ی $\phi$ها. 
 تابعِ 
$
d(i, j)
$
فاصله‌ی بین دو مکان و تابعِ 
$
f(i, j)
$
جریان بین دو مرکز رفاهی را برمی‌گرداند. در واقع کمینه‌سازیِ تابع هدف به شکل زیر شکل می‌گیرد:
\begin{latin}
$
min_{\phi \in S_{n}}(\sum_{i=1}^{n}\sum_{j=1}^{n} f(i, j)\times d(\phi(i), \phi(j)))
$
\end{latin}
در جایگشت همسایگی‌ها به شکل \lr{2-swap} می‌توانند تعریف شوند که در این صورت تابعِ هدف نظیر همسایه‌ی یک \lr{Candidate solution} تنها با تغییر
$f(i, j)\times d(\phi(i), \phi(j))$
به ازای $i$ و $j$های جایگزین شده میسر است و لازم به محاسبه مجدد همه‌ی عبارات نیست.


\section{مدل‌سازی}
\subsection{\lr{representation (definition of individuals)}}
نمایش جایگشت نمایش مناسبی برای این مسئله است. هر \lr{individual} در این مسئله را می‌توان به $d!$ بردار
$1 \times n$
نظیر کرد به طوری $n$ تعداد بسته‌ها و $d$ تعداد جعبه‌های مورد نیاز برای یک \lr{individual}  است و نحوه‌ی قرار گرفتن تعدادی بسته در هر جعبه به این شکل است که جایگشت را از چپ به راست پیمایش می‌کنیم و به صورت حریصانه تا جایی که ممکن است بسته در جعبه‌ی فعلی قرار می‌دهیم و در صورتی که جعبه جا نداشت سراغ جعبه‌ی جدید می‌رویم. البته هر دو جایگشت مختلف الزاما متناظر با دو \lr{individual} متفاوت نیستند و می‌توانند نظیر یک \lr{individual} یکتا باشند (جعبه‌ها یکسان‌اند و ترتیب قرارگیری جعبه‌ها اهمیتی ندارد و صرفا قرارگیری یا عدم قرارگیری تعدادی بسته در یک جعبه باعث تمایز \lr{individual}ها می‌شود. پس تعداد حالات $d!$ می‌شود.)
\newline
مجموعه‌ی شامل همه‌ی جایگشت‌های اعداد 1 تا $n$ را با $P_{n}$ نشان می‌دهیم.
\subsection{\lr{evaluation function (or fitness function)}}
حال \lr{fitness function} را می‌توانیم به شکل زیر تعریف کنیم:
\begin{latin}
$
\newline
f: P_{n} \to \mathbb{W}
\newline
x \in P_{n}
\newline
f(x) = Number \space of \space required \space boxes \space for \space x
$
\end{latin}


\subsection{\lr{population}}
جمعیت اولیه را می‌توان متشکل از تعدادی (مثلا 4) جایگشت تصادفی از $P_{n}$ پنداشت.
\subsection{\lr{parent selection mechanism}}
می‌توان متناسب با مقدار \lr{fitness} هر عضو از جمعیت، یک احتمال والد شدن به آن عضو نسبت داد و والد را از اعضای جمعیت با یک احتمال خاص انتخاب کرد (مانند مسئله‌ی $n$وزیر).
\subsection{\lr{variation operators, recombination and mutation}}
\subsubsection{\lr{recombination (crossover)}}
یک موضع دلخواه انتخاب می‌کنیم و دو والد را از آن موضعِ یکتا به دو بخش تقسیم می‌کنیم. بخش اول فرزند اول (دوم) را به ترتیب از بخش اول والد اول (دوم) انتخاب می‌کنیم و برای بخش دوم فرزند اول (دوم) والد دوم (اول) را از چپ پیمایش می‌کنیم و هر درایه‌ای که در بخش اول ظاهر نشده بود را به همان ترتیبی که در والد واقع شده است وارد فرزند می‌کنیم تا حالت جایگشت بودن حفظ شود.
\subsubsection{\lr{mutation}}
\lr{2-swap} می‌تواند یک \lr{mutation} مناسب برای این مسئله باشد. در واقع با یک احتمال دو درایه در فرزند را باهم جابه‌جا می‌کنیم. به این شکل جایگشت حفظ می‌شود.
\subsection{\lr{survivor selection mechanism (replacement)}}
مکانیسک انتخاب بازمانده می‌تواند به صورت \lr{fitness-based} یا \lr{age-based} باشد که در واقع در مکانیسم اول همه اعضای جمعیت را بر اساس \lr{fitness}شان رتبه بندی می‌کنیم و رتبه‌های بالا را به عنوان نسل بعد انتخاب می‌کنیم و در مکانیسم دوم می‌توان اعضای جوان‌تر (فرزندها) را صرفا حفظ کرد و والدها را کلا کنار بگذاریم.








\section{برنامه‌ریزی کلاس‌ها}
\subsection{\lr{representation (definition of individuals)}}
نمایش جایگشت نمایش مناسبی برای این مسئله است. هر \lr{individual} در این مسئله را می‌توان به یک بردار
$1 \times n^2$
نظیر کرد به طوری که درایه‌ی $i$ام آن، نظیر درایه‌ی سطرِ
$
\left\lceil \frac{i}{n} \right\rceil
$
و ستونِ
$
i \equiv r \pmod{n} 
$
(که $r$ باقی‌مانده است) در ماتریس \lr{Magic Square} است.
\newline
مجموعه‌ی شامل همه‌ی جایگشت‌های اعداد 1 تا $i$ را با $P_{i}$ نشان می‌دهیم.





\subsection{\lr{evaluation function (or fitness function)}}
حالت ایده‌آل زمانی است که مجموع همه‌ی درایه‌های سطرها(یا ستون‌ها یا قطرها) باهم برابر شوند. پس مجموع درایه‌های هر سطر، ستون یا قطر ($S$) برابر است با:

\begin{latin}
$
n \times S = \sum_{i = 1}^{n^2}i = \frac{n^2 \times(1 + n^2)}{2}
\Longrightarrow
S = \frac{n \times(1 + n^2)}{2}
$
\end{latin}
حال به عنوان \lr{fitness function} می‌توانیم مجموعِ فاصله‌های جمعِ درایه‌های هر سطر، ستون یا قطر را از ایده‌آل محاسبه کنیم. پس \lr{fitness function}  به شکل زیر تعریف می‌شود:

\begin{latin}
$
\newline
f: P_{n^2} \to \mathbb{Z}
\newline
f(x) =
n (n+1) (n^2 + 1)-
(   \sum_{i=1}^{n}(\sum_{j=1}^{n} \left| S - x_{i, j} \right|)
+ \sum_{j=1}^{n}(\sum_{i=1}^{n} \left| S - x_{i, j} \right|)
+ \sum_{i=1}^{n}\left| S - x_{i, i} \right|
+ \sum_{i=1}^{n}\left| S - x_{i, n-i+1} \right|)
$
\end{latin}
توجه شود چون معمولا در الگوریتم‌های تکامل مسئله را بیشینه‌سازی در نظر می‌گیرند، در اینجا عبارت را از یک مقدار بیشینه کم کردیم تا با یک مسئله‌ی بیشینه‌سازی رو‌به‌رو باشیم. در واقع فیتنسِ بهترین \lr{individual} برابر
$
n (n+1) (n^2 + 1)
$

\subsection{\lr{population}}
جمعیت اولیه را می‌توان متشکل از تعدادی (مثلا 4) جایگشت تصادفی از $P_{n^2}$ پنداشت.
\subsection{\lr{parent selection mechanism}}
می‌توان متناسب با مقدار \lr{fitness} هر عضو از جمعیت، یک احتمال والد شدن به آن عضو نسبت داد و والد را از اعضای جمعیت با یک احتمال خاص انتخاب کرد (مانند مسئله‌ی $n$وزیر).
\subsection{\lr{variation operators, recombination and mutation}}
\subsubsection{\lr{recombination (crossover)}}
یک موضع دلخواه انتخاب می‌کنیم و دو والد را از آن موضعِ یکتا به دو بخش تقسیم می‌کنیم. بخش اول فرزند اول (دوم) را به ترتیب از بخش اول والد اول (دوم) انتخاب می‌کنیم و برای بخش دوم فرزند اول (دوم) والد دوم (اول) را از چپ پیمایش می‌کنیم و هر درایه‌ای که در بخش اول ظاهر نشده بود را به همان ترتیبی که در والد واقع شده است وارد فرزند می‌کنیم تا حالت جایگشت بودن حفظ شود.
\subsubsection{\lr{mutation}}
\lr{2-swap} می‌تواند یک \lr{mutation} مناسب برای این مسئله باشد. در واقع با یک احتمال دو درایه در فرزند را باهم جابه‌جا می‌کنیم. به این شکل جایگشت حفظ می‌شود.
\subsection{\lr{survivor selection mechanism (replacement)}}
مکانیسک انتخاب بازمانده می‌تواند به صورت \lr{fitness-based} یا \lr{age-based} باشد که در واقع در مکانیسم اول همه اعضای جمعیت را بر اساس \lr{fitness}شان رتبه بندی می‌کنیم و رتبه‌های بالا را به عنوان نسل بعد انتخاب می‌کنیم و در مکانیسم دوم می‌توان اعضای جوان‌تر (فرزندها) را صرفا حفظ کرد و والدها را کلا کنار بگذاریم.

\section{\lr{Puzzle Cryptarithmetic}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{منابع}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{99} % assumes less than 100 references
%چنانچه مرجع فارسی نیز داشته باشید باید دستور فوق را فعال کنید و مراجع فارسی خود را بعد از این دستور وارد کنید


\begin{LTRitems}

\resetlatinfont

\bibitem{b1}
\end{LTRitems}

\end{thebibliography}


\end{document}
